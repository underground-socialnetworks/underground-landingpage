'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadMetadata = loadMetadata;

var _urls = require('../urls');

var _urls2 = _interopRequireDefault(_urls);

var _request = require('../request');

var _request2 = _interopRequireDefault(_request);

var _cluster = require('./cluster');

var _cluster2 = _interopRequireDefault(_cluster);

var _point = require('./point');

var _point2 = _interopRequireDefault(_point);

var _query = require('./query');

var _query2 = _interopRequireDefault(_query);

var _findHelpers = require('./find-helpers');

var _findHelpers2 = _interopRequireDefault(_findHelpers);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//TODO: refactor me

function loadMetadata(geoObject, asyncHandler) {
  var isCluster = geoObject instanceof _cluster2.default;
  var isPoint = geoObject instanceof _point2.default;

  if (!geoObject.objectId || !isCluster && !isPoint) {
    throw new Error('Method argument must be a valid instance of GeoPoint or GeoCluster persisted on the server');
  }

  var url = _urls2.default.geoPointMetaData(geoObject.objectId);

  if (isCluster) {
    var geoQuery = geoObject.geoQuery;

    if (!(geoQuery instanceof _query2.default)) {
      throw new Error('Invalid GeoCluster object. ' + 'Make sure to obtain an instance of GeoCluster using the Backendless.Geo.find API');
    }

    url += '?';

    for (var prop in geoQuery) {
      if (geoQuery.hasOwnProperty(prop) && _findHelpers2.default.hasOwnProperty(prop) && geoQuery[prop] != null) {
        url += '&' + _findHelpers2.default[prop](geoQuery[prop]);
      }
    }
  }

  return _request2.default.get({
    url: url,
    isAsync: !!asyncHandler,
    asyncHandler: asyncHandler
  });
}