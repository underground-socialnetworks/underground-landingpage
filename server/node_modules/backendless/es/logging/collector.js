'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = require('../utils');

var _utils2 = _interopRequireDefault(_utils);

var _urls = require('../urls');

var _urls2 = _interopRequireDefault(_urls);

var _request = require('../request');

var _request2 = _interopRequireDefault(_request);

var _async = require('../request/async');

var _async2 = _interopRequireDefault(_async);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var lastFlushListeners = void 0;

function flush(asyncHandler) {
  if (LoggingCollector.pool.length) {
    if (LoggingCollector.flushInterval) {
      clearTimeout(LoggingCollector.flushInterval);
    }

    var listeners = void 0;

    var cb = function cb(method) {
      return function () {
        var _arguments = arguments;

        listeners.forEach(function (callbacks) {
          callbacks[method].apply(null, _arguments);
        });

        if (listeners === lastFlushListeners) {
          lastFlushListeners = null;
        }
      };
    };

    if (asyncHandler) {
      listeners = lastFlushListeners = lastFlushListeners ? lastFlushListeners.splice(0) : [];
      listeners.push(asyncHandler);
    }

    _request2.default.put({
      isAsync: !!asyncHandler,
      asyncHandler: asyncHandler && new _async2.default(cb('success'), cb('fault')),
      url: _urls2.default.logging(),
      data: LoggingCollector.pool
    });

    LoggingCollector.pool = [];
  } else if (asyncHandler) {
    if (lastFlushListeners) {
      lastFlushListeners.push(asyncHandler);
    } else {
      setTimeout(asyncHandler.success, 0);
    }
  }
}

var LoggingCollector = {
  reset: function reset() {
    LoggingCollector.loggers = {};
    LoggingCollector.pool = [];
    LoggingCollector.numOfMessages = 10;
    LoggingCollector.timeFrequency = 1;
  },
  getLogger: function getLogger(loggerName) {
    var _require = require('./logger'),
        Logger = _require.default;

    if (!_utils2.default.isString(loggerName)) {
      throw new Error("Invalid 'loggerName' value. LoggerName must be a string value");
    }

    return LoggingCollector.loggers[loggerName] = LoggingCollector.loggers[loggerName] || new Logger(loggerName);
  },
  push: function push(logger, logLevel, message, exception) {
    var messageObj = {
      logger: logger,
      message: message,
      exception: exception,
      'log-level': logLevel,
      timestamp: Date.now()
    };

    LoggingCollector.pool.push(messageObj);

    LoggingCollector.checkMessagesLen();
  },
  checkMessagesLen: function checkMessagesLen() {
    if (LoggingCollector.pool.length >= LoggingCollector.numOfMessages) {
      LoggingCollector.sendRequest();
    }
  },


  flush: _utils2.default.promisified(flush),
  flushSync: _utils2.default.synchronized(flush),

  sendRequest: function sendRequest() {
    if (!LoggingCollector.flushInterval) {
      LoggingCollector.flushInterval = setTimeout(function () {
        return LoggingCollector.flush();
      }, LoggingCollector.timeFrequency * 1000);
    }
  },
  setLogReportingPolicy: function setLogReportingPolicy(numOfMessages, timeFrequency) {
    LoggingCollector.numOfMessages = numOfMessages;
    LoggingCollector.timeFrequency = timeFrequency;

    //TODO: check when set new timeFrequency
    LoggingCollector.checkMessagesLen();
  }
};

LoggingCollector.reset();

exports.default = LoggingCollector;