'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.startMonitoring = startMonitoring;

var _urls = require('../../urls');

var _urls2 = _interopRequireDefault(_urls);

var _request = require('../../request');

var _request2 = _interopRequireDefault(_request);

var _point = require('../point');

var _point2 = _interopRequireDefault(_point);

var _utils = require('../utils');

var _utils2 = _interopRequireDefault(_utils);

var _tracker = require('./tracker');

var _tracker2 = _interopRequireDefault(_tracker);

var _fenceActions = require('./fence-actions');

var _fenceActions2 = _interopRequireDefault(_fenceActions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var INTERVAL = 5000;

//TODO: refactor me

function getFences(geoFence) {
  return _request2.default.get({
    url: _urls2.default.geoFences(geoFence)
  });
}

function isDefiniteRect(nwPoint, sePoint) {
  return nwPoint != null && sePoint != null;
}

var TypesMapper = {
  'RECT': function RECT(fence) {
    fence.nwPoint = fence.nodes[0];
    fence.sePoint = fence.nodes[1];
  },
  'CIRCLE': function CIRCLE(fence) {
    var outRect = _utils2.default.getOutRectangle(fence.nodes[0], fence.nodes[1]);
    fence.nwPoint = {
      latitude: outRect[0],
      longitude: outRect[1]
    };
    fence.sePoint = {
      latitude: outRect[2],
      longitude: outRect[3]
    };
  },
  'SHAPE': function SHAPE(fence) {
    var outRect = _utils2.default.getOutRectangle(fence.nodes[0], fence.nodes[1]);
    fence.nwPoint = {
      latitude: outRect[0],
      longitude: outRect[1]
    };
    fence.sePoint = {
      latitude: outRect[2],
      longitude: outRect[3]
    };
  }
};

function checkPosition(geofenceName, coords, fences, geoPoint, GeoFenceCallback, lastResults, asyncHandler) {
  var tracker = _tracker2.default.get();

  for (var k = 0; k < tracker._trackedFences.length; k++) {
    var _trackedFences = tracker._trackedFences[k];

    var isInFence = isDefiniteRect(_trackedFences.nwPoint, _trackedFences.sePoint) && _utils2.default.isPointInFence(coords, _trackedFences);

    var rule = null;

    if (isInFence !== lastResults[tracker._trackedFences[k].geofenceName]) {
      if (lastResults[tracker._trackedFences[k].geofenceName]) {
        rule = 'onexit';
      } else {
        rule = 'onenter';
      }

      lastResults[tracker._trackedFences[k].geofenceName] = isInFence;
    }

    if (rule) {
      (function () {
        var duration = tracker._trackedFences[k].onStayDuration * 1000;

        var timeoutFuncInApp = function timeoutFuncInApp(savedK, savedCoords, duration) {
          var callBack = function callBack() {
            GeoFenceCallback['onstay'](tracker._trackedFences[savedK].geofenceName, tracker._trackedFences[savedK].objectId, savedCoords.latitude, savedCoords.longitude);
          };

          tracker._timers[tracker._trackedFences[savedK].geofenceName] = setTimeout(callBack, duration);
        };

        var timeoutFuncRemote = function timeoutFuncRemote(savedK, savedCoords, duration, geoPoint) {
          var callBack = function callBack() {
            _fenceActions2.default.run('onstay', tracker._trackedFences[savedK].geofenceName, geoPoint, asyncHandler);
          };

          tracker._timers[tracker._trackedFences[savedK].geofenceName] = setTimeout(callBack, duration);
        };

        if (GeoFenceCallback) {
          if (rule === 'onenter') {
            GeoFenceCallback[rule](tracker._trackedFences[k].geofenceName, tracker._trackedFences[k].objectId, coords.latitude, coords.longitude);

            if (duration > -1) {
              (function (k, coords, duration) {
                return timeoutFuncInApp(k, coords, duration);
              })(k, coords, duration);
            } else {
              GeoFenceCallback['onstay'](tracker._trackedFences[k].geofenceName, tracker._trackedFences[k].objectId, coords.latitude, coords.longitude);
            }
          } else {
            clearTimeout(tracker._timers[tracker._trackedFences[k].geofenceName]);
            GeoFenceCallback[rule](tracker._trackedFences[k].geofenceName, tracker._trackedFences[k].objectId, coords.latitude, coords.longitude);
          }
        } else if (geoPoint) {
          geoPoint.latitude = coords.latitude;
          geoPoint.longitude = coords.longitude;

          if (rule === 'onenter') {
            _fenceActions2.default.run(rule, tracker._trackedFences[k].geofenceName, geoPoint, asyncHandler);

            if (duration > -1) {
              (function (k, coords, duration, geoPoint) {
                return timeoutFuncRemote(k, coords, duration, geoPoint);
              })(k, coords, duration, geoPoint);
            } else {
              _fenceActions2.default.run('onstay', tracker._trackedFences[k].geofenceName, geoPoint, asyncHandler);
            }
          } else {
            clearTimeout(tracker._timers[tracker._trackedFences[k].geofenceName]);
            _fenceActions2.default.run(rule, tracker._trackedFences[k].geofenceName, geoPoint, asyncHandler);
          }
        }
      })();
    }
  }
}

function startMonitoring(geofenceName, secondParam, asyncHandler) {
  var tracker = _tracker2.default.get();

  var isGeoPoint = false;

  if (secondParam instanceof _point2.default) {
    isGeoPoint = true;
  }

  var fences = getFences(geofenceName);

  for (var ii = 0; ii < fences.length; ii++) {
    if (!_containsByPropName(tracker._trackedFences, fences[ii], 'geofenceName')) {
      TypesMapper[fences[ii].type](fences[ii]);
      tracker._lastResults[fences[ii].geofenceName] = false;
      tracker._trackedFences.push(fences[ii]);
    }
  }

  function _containsByPropName(collection, object, name) {
    var length = collection.length;
    var result = false;

    for (var i = 0; i < length; i++) {
      if (result = collection[i][name] === object[name]) {
        break;
      }
    }

    return result;
  }

  var getPosition = function getPosition(position) {
    var geoPoint = isGeoPoint ? secondParam : null;
    var callback = !isGeoPoint ? secondParam : null;

    checkPosition(geofenceName, position.coords, fences, geoPoint, callback, tracker._lastResults, asyncHandler);
  };

  function errorCallback(error) {
    throw new Error('Error during current position calculation. Error ' + error.message);
  }

  function getCurPos() {
    navigator.geolocation.getCurrentPosition(getPosition, errorCallback, {
      timeout: 5000,
      enableHighAccuracy: true
    });
  }

  if (!tracker.monitoringId) {
    if (fences.length) {
      tracker.monitoringId = !_utils2.default.isMobileDevice() ? setInterval(getCurPos, INTERVAL) : navigator.geolocation.watchPosition(getPosition, errorCallback, {
        timeout: INTERVAL,
        enableHighAccuracy: true
      });
    } else {
      throw new Error('Please, add some fences to start monitoring');
    }
  }
}