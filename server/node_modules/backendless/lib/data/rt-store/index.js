'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _rt = require('../../rt');

var _parse = require('../store/parse');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ChangesTypes = {
  CREATED: 'created',
  UPDATED: 'updated',
  DELETED: 'deleted',

  BULK_CREATED: 'bulk-created',
  BULK_UPDATED: 'bulk-updated',
  BULK_DELETED: 'bulk-deleted'
};

var SingleChangesTypes = [ChangesTypes.CREATED, ChangesTypes.UPDATED, ChangesTypes.DELETED];

var EventHandler = function (_RTListeners) {
  _inherits(EventHandler, _RTListeners);

  function EventHandler(dataStore) {
    _classCallCheck(this, EventHandler);

    var _this = _possibleConstructorReturn(this, (EventHandler.__proto__ || Object.getPrototypeOf(EventHandler)).call(this));

    _this.parseObjectToInstance = function (object) {
      //TODO: "parseFindResponse" method must be moved to dataStore
      return (0, _parse.parseFindResponse)(object, _this.dataStore.model);
    };

    _this.dataStore = dataStore;
    return _this;
  }

  _createClass(EventHandler, [{
    key: 'getSubscriptionOptions',
    value: function getSubscriptionOptions() {
      return {
        tableName: this.dataStore.className
      };
    }
  }, {
    key: 'addCreateListener',
    value: function addCreateListener(whereClause, callback, onError) {
      this.addChangesListener(ChangesTypes.CREATED, whereClause, callback, onError);
    }
  }, {
    key: 'removeCreateListeners',
    value: function removeCreateListeners(whereClause, callback) {
      this.removeChangesListeners(ChangesTypes.CREATED, whereClause, callback);
    }
  }, {
    key: 'removeCreateListener',
    value: function removeCreateListener(callback) {
      if (!callback) {
        throw new Error('Listener Function must be passed.');
      }

      this.removeCreateListeners(undefined, callback);
    }
  }, {
    key: 'addUpdateListener',
    value: function addUpdateListener(whereClause, callback, onError) {
      this.addChangesListener(ChangesTypes.UPDATED, whereClause, callback, onError);
    }
  }, {
    key: 'removeUpdateListeners',
    value: function removeUpdateListeners(whereClause, callback) {
      this.removeChangesListeners(ChangesTypes.UPDATED, whereClause, callback);
    }
  }, {
    key: 'removeUpdateListener',
    value: function removeUpdateListener(callback) {
      if (!callback) {
        throw new Error('Listener Function must be passed.');
      }

      this.removeUpdateListeners(undefined, callback);
    }
  }, {
    key: 'addDeleteListener',
    value: function addDeleteListener(whereClause, callback, onError) {
      this.addChangesListener(ChangesTypes.DELETED, whereClause, callback, onError);
    }
  }, {
    key: 'removeDeleteListeners',
    value: function removeDeleteListeners(whereClause, callback) {
      this.removeChangesListeners(ChangesTypes.DELETED, whereClause, callback);
    }
  }, {
    key: 'removeDeleteListener',
    value: function removeDeleteListener(callback) {
      if (!callback) {
        throw new Error('Listener Function must be passed.');
      }

      this.removeDeleteListeners(undefined, callback);
    }
  }, {
    key: 'addBulkCreateListener',
    value: function addBulkCreateListener(whereClause, callback, onError) {
      this.addChangesListener(ChangesTypes.BULK_CREATED, whereClause, callback, onError);
    }
  }, {
    key: 'removeBulkCreateListeners',
    value: function removeBulkCreateListeners() {
      this.removeChangesListeners(ChangesTypes.BULK_CREATED);
    }
  }, {
    key: 'removeBulkCreateListener',
    value: function removeBulkCreateListener(callback) {
      if (!callback) {
        throw new Error('Listener Function must be passed.');
      }

      this.removeChangesListeners(ChangesTypes.BULK_CREATED, undefined, callback);
    }
  }, {
    key: 'addBulkUpdateListener',
    value: function addBulkUpdateListener(whereClause, callback, onError) {
      this.addChangesListener(ChangesTypes.BULK_UPDATED, whereClause, callback, onError);
    }
  }, {
    key: 'removeBulkUpdateListeners',
    value: function removeBulkUpdateListeners(whereClause, callback) {
      this.removeChangesListeners(ChangesTypes.BULK_UPDATED, whereClause, callback);
    }
  }, {
    key: 'removeBulkUpdateListener',
    value: function removeBulkUpdateListener(callback) {
      if (!callback) {
        throw new Error('Listener Function must be passed.');
      }

      this.removeBulkUpdateListeners(undefined, callback);
    }
  }, {
    key: 'addBulkDeleteListener',
    value: function addBulkDeleteListener(whereClause, callback, onError) {
      this.addChangesListener(ChangesTypes.BULK_DELETED, whereClause, callback, onError);
    }
  }, {
    key: 'removeBulkDeleteListeners',
    value: function removeBulkDeleteListeners(whereClause, callback) {
      this.removeChangesListeners(ChangesTypes.BULK_DELETED, whereClause, callback);
    }
  }, {
    key: 'removeBulkDeleteListener',
    value: function removeBulkDeleteListener(callback) {
      if (!callback) {
        throw new Error('Listener Function must be passed.');
      }

      this.removeBulkDeleteListeners(undefined, callback);
    }
  }, {
    key: 'addChangesListener',
    value: function addChangesListener(event, whereClause, callback, onError) {
      (0, _rt.checkUsesInBusinessLogic)('Subscribe on Data changes');

      if (typeof whereClause === 'function') {
        onError = callback;
        callback = whereClause;
        whereClause = undefined;
      }

      if (typeof callback !== 'function') {
        throw new Error('"callback" must be function.');
      }

      this.addSubscription(event, _rt.RTClient.subscriptions.onObjectsChanges, {
        callback: callback,
        onError: onError,
        parser: SingleChangesTypes.includes(event) ? this.parseObjectToInstance : undefined,
        params: {
          event: event,
          whereClause: whereClause
        }
      });
    }
  }, {
    key: 'removeChangesListeners',
    value: function removeChangesListeners(event, whereClause, callback) {
      if (typeof whereClause === 'function') {
        callback = whereClause;
        whereClause = undefined;
      }

      var matcher = function matcher(subscription) {
        var params = subscription.params;

        if (params.event !== event) {
          return false;
        }

        if (whereClause) {
          return params.whereClause === whereClause;
        }

        if (callback) {
          return subscription.callback === callback;
        }

        return true;
      };

      this.stopSubscription(event, { matcher: matcher });
    }
  }]);

  return EventHandler;
}(_rt.RTListeners);

exports.default = EventHandler;