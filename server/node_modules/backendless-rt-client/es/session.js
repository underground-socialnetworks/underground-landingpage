'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _constants = require('./constants');

var _socket = require('./socket');

var _socket2 = _interopRequireDefault(_socket);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var INCREASE_RECONNECTION_TIMEOUT_STEP = 10;
var INITIAL_RECONNECTION_TIMEOUT = 200;
var MAX_RECONNECTION_TIMEOUT = 60 * 1000; // a minute

var wait = function wait(milliseconds) {
  return new Promise(function (resolve) {
    return setTimeout(resolve, milliseconds);
  });
};

var RTSession = function () {
  function RTSession(config, dispatch, onDisconnect) {
    _classCallCheck(this, RTSession);

    this.config = config;
    this.dispatch = dispatch;
    this.onDisconnect = onDisconnect;

    this.connectAttempt = 0;

    this.socketPromise = this.connect();
  }

  _createClass(RTSession, [{
    key: 'terminate',
    value: function terminate() {
      if (!this.terminated) {
        this.terminated = true;

        this.dispatch = function () {
          //if sessions has been terminated don't need to dispatch any events
        };

        this.socketPromise.then(function (rtSocket) {
          if (rtSocket) {
            rtSocket.close();
          }
        });
      }
    }
  }, {
    key: 'getSocket',
    value: function getSocket() {
      var _this = this;

      return this.socketPromise.then(function (rtSocket) {
        if (_this.terminated) {
          return new Promise(function () {
            //return unresolvable promise for preventing errors
            //this connection session has been terminated and a new one will be created if it necessary
          });
        }

        return rtSocket;
      });
    }
  }, {
    key: 'connect',
    value: function connect() {
      var _this2 = this;

      if (this.terminated) {
        return;
      }

      this.connectAttempt = this.connectAttempt + 1;

      var nextReconnectionTimeout = this.getNextReconnectionTimeout();

      this.onConnecting();

      if (this.connectAttempt > 1) {
        this.onReconnectAttempt(this.connectAttempt - 1, nextReconnectionTimeout);
      }

      return _socket2.default.connect(this.config, this.onSocketDisconnect.bind(this)).then(function (rtSocket) {
        _this2.connectAttempt = 0;

        _this2.onConnect();

        return rtSocket;
      }).catch(function (error) {
        _this2.onConnectError(error);

        if (!_this2.terminated) {
          // wait for 400|800|1600|...|MAX_RECONNECTION_TIMEOUT milliseconds
          return wait(nextReconnectionTimeout).then(function () {
            return _this2.connect();
          });
        }
      });
    }
  }, {
    key: 'getNextReconnectionTimeout',
    value: function getNextReconnectionTimeout() {
      var factor = Math.ceil(this.connectAttempt / INCREASE_RECONNECTION_TIMEOUT_STEP);
      var timeout = INITIAL_RECONNECTION_TIMEOUT * Math.pow(2, factor);

      return Math.min(timeout, MAX_RECONNECTION_TIMEOUT);
    }
  }, {
    key: 'onSocketDisconnect',
    value: function onSocketDisconnect(reason) {
      this.dispatch(_constants.NativeSocketEvents.DISCONNECT, reason);

      if (!this.terminated) {
        this.terminate();

        this.onDisconnect();
      }
    }
  }, {
    key: 'onConnecting',
    value: function onConnecting() {
      this.dispatch(_constants.NativeSocketEvents.CONNECTING);
    }
  }, {
    key: 'onConnect',
    value: function onConnect() {
      this.dispatch(_constants.NativeSocketEvents.CONNECT);
    }
  }, {
    key: 'onConnectError',
    value: function onConnectError(error) {
      this.dispatch(_constants.NativeSocketEvents.CONNECT_ERROR, error && error.message || error);
    }
  }, {
    key: 'onReconnectAttempt',
    value: function onReconnectAttempt(attempt, timeout) {
      this.dispatch(_constants.NativeSocketEvents.RECONNECT_ATTEMPT, attempt, timeout);
    }
  }]);

  return RTSession;
}();

exports.default = RTSession;