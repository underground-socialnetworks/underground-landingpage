'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _constants = require('./constants');

var _config = require('./config');

var _config2 = _interopRequireDefault(_config);

var _subscriptions = require('./subscriptions');

var _subscriptions2 = _interopRequireDefault(_subscriptions);

var _methods = require('./methods');

var _methods2 = _interopRequireDefault(_methods);

var _session = require('./session');

var _session2 = _interopRequireDefault(_session);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CONNECTION_MANAGE_EVENTS = [_constants.NativeSocketEvents.CONNECTING, _constants.NativeSocketEvents.CONNECT, _constants.NativeSocketEvents.CONNECT_ERROR, _constants.NativeSocketEvents.DISCONNECT, _constants.NativeSocketEvents.RECONNECT_ATTEMPT];

var RTClient = function () {
  function RTClient(config) {
    var _this = this;

    _classCallCheck(this, RTClient);

    this.connectOnMethod = function (method) {
      return function () {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        if (_this.connectible) {
          var rtSocketPromise = _this.provideConnection();

          if (_this.connected) {
            rtSocketPromise.then(function (rtSocket) {
              return rtSocket[method].apply(rtSocket, args);
            });
          }
        }
      };
    };

    this.on = this.connectOnMethod('on');
    this.emit = this.connectOnMethod('emit');

    this.onSessionDisconnect = function () {
      _this.subscriptions.stop();
      _this.methods.stop();

      delete _this.session;

      _this.provideConnection();
    };

    this.emitSocketEventListeners = function (event) {
      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      if (_this.socketEvents[event]) {
        _this.socketEvents[event].forEach(function (callback) {
          return callback.apply(undefined, args);
        });
      }
    };

    this.addConnectingEventListener = function (callback) {
      return _this.addSocketEventListener(_constants.NativeSocketEvents.CONNECTING, callback);
    };

    this.removeConnectingEventListener = function (callback) {
      return _this.removeSocketEventListener(_constants.NativeSocketEvents.CONNECTING, callback);
    };

    this.addConnectEventListener = function (callback) {
      return _this.addSocketEventListener(_constants.NativeSocketEvents.CONNECT, callback);
    };

    this.removeConnectEventListener = function (callback) {
      return _this.removeSocketEventListener(_constants.NativeSocketEvents.CONNECT, callback);
    };

    this.addConnectErrorEventListener = function (callback) {
      return _this.addSocketEventListener(_constants.NativeSocketEvents.CONNECT_ERROR, callback);
    };

    this.removeConnectErrorEventListener = function (callback) {
      return _this.removeSocketEventListener(_constants.NativeSocketEvents.CONNECT_ERROR, callback);
    };

    this.addDisconnectEventListener = function (callback) {
      return _this.addSocketEventListener(_constants.NativeSocketEvents.DISCONNECT, callback);
    };

    this.removeDisconnectEventListener = function (callback) {
      return _this.removeSocketEventListener(_constants.NativeSocketEvents.DISCONNECT, callback);
    };

    this.addReconnectAttemptEventListener = function (callback) {
      return _this.addSocketEventListener(_constants.NativeSocketEvents.RECONNECT_ATTEMPT, callback);
    };

    this.removeReconnectAttemptEventListener = function (callback) {
      return _this.removeSocketEventListener(_constants.NativeSocketEvents.RECONNECT_ATTEMPT, callback);
    };

    this.removeConnectionListeners = function () {
      CONNECTION_MANAGE_EVENTS.forEach(function (event) {
        return _this.removeSocketEventListener(event);
      });
    };

    this.config = new _config2.default(config);

    this.socketEvents = {};

    var socketContext = {
      onMessage: this.on.bind(this),
      emitMessage: this.emit.bind(this)
    };

    this.subscriptions = new _subscriptions2.default(socketContext);
    this.methods = new _methods2.default(socketContext);

    this.connectible = true;
    this.connected = false;
  }

  _createClass(RTClient, [{
    key: 'setConfig',
    value: function setConfig(config) {
      this.config.set(config);

      if (this.session) {
        this.disconnect('Re-config socket connection');

        this.connect();
      }
    }
  }, {
    key: 'provideConnection',
    value: function provideConnection() {
      var _this2 = this;

      if (!this.session) {
        this.session = new _session2.default(this.config, this.emitSocketEventListeners, this.onSessionDisconnect);
        this.session.getSocket().then(function () {
          _this2.connected = true;

          _this2.methods.initialize();

          _this2.subscriptions.initialize();
          _this2.subscriptions.restore();
        });
      }

      return this.session.getSocket();
    }
  }, {
    key: 'connect',
    value: function connect() {
      this.connectible = true;

      this.provideConnection();
    }
  }, {
    key: 'disconnect',
    value: function disconnect(reason) {
      if (this.session) {
        this.subscriptions.stop();
        this.methods.stop();

        this.session.terminate();

        delete this.session;

        this.emitSocketEventListeners(_constants.NativeSocketEvents.DISCONNECT, reason || 'disconnected by client');
      }

      this.connectible = false;
      this.connected = false;
    }
  }, {
    key: 'terminate',
    value: function terminate(reason) {
      this.socketEvents = {};

      this.subscriptions.reset();
      this.methods.reset();

      this.disconnect(reason || 'Terminated by client');
    }
  }, {
    key: 'addSocketEventListener',
    value: function addSocketEventListener(event, callback) {
      this.socketEvents[event] = this.socketEvents[event] || [];
      this.socketEvents[event].push(callback);

      return this;
    }
  }, {
    key: 'removeSocketEventListener',
    value: function removeSocketEventListener(event, callback) {
      if (this.socketEvents[event]) {
        this.socketEvents[event] = callback ? this.socketEvents[event].filter(function (cb) {
          return cb !== callback;
        }) : [];

        if (!this.socketEvents[event].length) {
          delete this.socketEvents[event];
        }
      }

      return this;
    }
  }]);

  return RTClient;
}();

exports.default = RTClient;